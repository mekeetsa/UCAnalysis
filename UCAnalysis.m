(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(*
   Uncertainty Analysis
   Package for analysis of uncertainty propagations in Physics
   Author: Mikica B Kocic
   Version: 2.5, 2011-10-15
*)


$Pre =.


BeginPackage[ "UCAnalysis`", { "UCQuantity`" } ];


ClearAll[ "UCAnalysis`Private`*" ];
ClearAll[ "UCAnalysis`*" ];


Get@ "UCA-CODATA.m"


$UcPrecision := 2;
$UcPrecision::usage = "Number of significant digits in uncertainty part."


$EstPrecision := 6;
$EstPrecision::usage = "Shown number of significant digits in estimate part."


SetInputQuantities::usage = "Setup input quantites as Uc\[ScriptCapitalV] from matrix"
AddInputQuantities::usage = "Setup input quantites as Uc\[ScriptCapitalV] from matrix"
SetupFunctionalRelationship::usage = "Setup UA from an expression"
SetupUA::usage = "Setup analysis environment from an Uc\[ScriptCapitalF] object"
ClearUA::usage = "Clears all public analysis environment variables"


n::usage = "Number of input quantities"
\[CapitalKoppa]X::usage = "i-th input quantity"
fDist::usage = "Distribution of the i-th input quantity"
\[CapitalKoppa]fSensitivityOfX::usage = ""
\[CapitalKoppa]MaxSigFigures::usage = "Maximum precison of all input quantities"


\[CapitalKoppa]fDomain::usage = ""
\[CapitalKoppa]Vector::usage = ""
\[CapitalKoppa]Verbose::usage = ""
\[CapitalKoppa]VerboseArgs::usage = ""
\[CapitalKoppa]AsMaximumUncertainty::usage = ""
\[CapitalKoppa]AsStandardUncertainty::usage = ""


f::usage = "Functional relationship between input quantities and the result"


\[CapitalKoppa]Y::usage = "esitmate \[PlusMinus] extended uncertainty"
\[CapitalKoppa]Y$CoverFactor::usage = "cover factor of the extended uncertainty"
\[CapitalKoppa]Y$Options::usage = ""
\[CapitalKoppa]fMaxValue::usage = ""
\[CapitalKoppa]fMinValue::usage = ""
\[CapitalKoppa]fEstimate::usage = ""
\[CapitalKoppa]fStandardUncertainty::usage = ""
\[CapitalKoppa]fMaximumUncertainty::usage = ""
\[CapitalKoppa]MonteCarlo::usage = ""


\[CapitalKoppa]FunctionalRelationship::usage = ""
\[CapitalKoppa]InputQuantities::usage = ""
\[CapitalKoppa]AnalysisResult::usage = ""
\[CapitalKoppa]AnalysisEnvironment::usage = ""
\[CapitalKoppa]DumpRelationship::usage = ""
\[CapitalKoppa]DumpQuantities::usage = ""


\[CapitalKoppa]UC::usage = ""
\[CapitalKoppa]UCU::usage = ""
\[CapitalKoppa]UCResult::usage = ""
\[CapitalKoppa]UCA::usage = ""
\[CapitalKoppa]UCE::usage = ""


Options[ \[CapitalKoppa]UCU ] = Options[ \[CapitalKoppa]UCResult ] =
{
  Precision -> Null,   (* number of sig figures in est part *)
  UcPrecision -> Null, (* number of sig figures in uc part *)
  CoverFactor -> 1
};


Begin[ "UCAnalysis`Private`" ];


BracketingBar[ expr_ ] := Abs[ expr ];


PercentForm[ expr_, pct_: 100 ] := 
Module[
  { v = If[ pct == 0, Infinity, N[ Abs[ expr / pct ] ] ] },

  If[ ! NumericQ[ expr ] || ! NumericQ[ pct ],
    Return[ Indeterminate ]
  ];

  DisplayForm@ If[ v == Infinity, 
  (* Then *) 
    RowBox[{ "\[Infinity]" }],
  (* Else *)
    If[ Abs[v] < 10^-3,
      (* Then *) RowBox[{ ToBoxes[ NumberForm[ v * 10^6, 3 ] ], "ppm" }],
      (* Else *) RowBox[{ ToBoxes[ NumberForm[ v * 100, 3 ] ], "%" }]
    ]
  ]
];


SetAttributes[ TimeIt, HoldAll ];


TimeIt[ expr_ ] :=
Module[ 
  { result = expr, out, form },
  If[ TrueQ[ MemberQ[ $OutputForms, Head[result] ] ],
    (* Then *) out = First[result]; form = "//" <> ToString[ Head[result] ], 
    (* Else *) out = result; form = ""
  ];
  If[ out =!= Null,
    CellPrint[
      ExpressionCell[ result, "Output", 
        CellLabelAutoDelete -> True,
        CellLabel -> StringJoin[ "Out[", ToString[$Line], "]:="]
      ]
    ];
    Unprotect[ Out ];
    Out[ $Line ] = out;
    Protect[ Out ];
    out (* needed for % *)
  ];
];


\[CapitalKoppa]MonteCarlo[ trials_ : 10^6 ] :=
Module[
  { data },
  PrintTemporary[ Style[ "Working...", FontColor -> Red, FontWeight -> Bold ] ];
  data = f @@ Table[ RandomReal[ fDist[ i ], {trials} ], { i, n } ];
  ToUc\[ScriptCapitalV][
    Mean[data] \[PlusMinus] ( StandardDeviation[data] * \[CapitalKoppa]Y$CoverFactor ),
    Distribution -> Normal\[ScriptCapitalD], CoverFactor -> \[CapitalKoppa]Y$CoverFactor,
    Sequence @@ \[CapitalKoppa]Y$Options
  ]
];


VerboseDistribution[ qty_? ExactUc\[ScriptCapitalV]Q ] := "-";


VerboseDistribution[ qty_? UncertainUc\[ScriptCapitalV]Q ] := 
Module[
  {
    dist = UCQuantity`Private`NullifyIfEmpty[ Uc\[ScriptCapitalV]$Option[ qty, Distribution ] ],
    coverFactor = Uc\[ScriptCapitalV]$Option[ qty, CoverFactor ]
  },
  If[ coverFactor === Null, coverFactor = 1 ];
  Switch[ dist,
    Normal\[ScriptCapitalD],     "Normal, " <> ToString[ coverFactor ] <> "\[Sigma]",
    Uniform\[ScriptCapitalD],    "Uniform",
    Triangular\[ScriptCapitalD], "Triangular",
    _,           ""
  ]
];


VerboseDistribution[ qty_? IndeterminateUc\[ScriptCapitalV]Q ] := "?";


InputQuantitiesTable[ xSymb_, X_, n_ ] := 
Table[ 
  { 
    DisplayForm@ RowBox[{ SubscriptBox[ xSymb, i ] }],
    Module[
      { nameBox = Uc\[ScriptCapitalV]$NameBox[ X[i] ] },
      If[ nameBox =!= Null, (* Then *) DisplayForm@ nameBox ]
    ],
    DisplayForm@ UcBox[ X[i] ],
    Module[
      { unitBox = Uc\[ScriptCapitalV]$UnitBox[ X[i] ] },
      If[ unitBox =!= Null, (* Then *) DisplayForm@ unitBox ]
    ],
    VerboseDistribution[ X[i] ],
    ScientificForm[ N@ \[CapitalKoppa]fSensitivityOfX[ i ] ]
  },
  { i, n }
];


InputQuantitiesGrid[ xSymb_, X_, n_ ] :=
Module[
  {},
  If[ n == 0, Return[] ];
  Grid[
    Join[
      {
        { "Quantity", SpanFromLeft, 
          "Estimate \[PlusMinus] Uncertainty", "Units", "Distribution",
          Style[ "\[LeftBracketingBar]\[ThinSpace]\[PartialD]f/\[PartialD]\!\(\*SubscriptBox[\"x\", \"i\"]\)\[RightBracketingBar]", FontFamily -> "Courier" ]
          },
        { "", SpanFromLeft, (*"",*) "", "", "", "" }
      },
      {{ (*Empty Row*) }},
      InputQuantitiesTable[ xSymb, X, n ],
      {{ (*Empty Row*) }}
    ],
    ItemStyle -> { 
      { Automatic }, 
      { Directive[ Bold, FontFamily -> "Helvetica", FontSize -> Smaller ] }
    },
    Alignment -> {
      { Left, Center, { Left } },
      { Baseline },
      { {1, 1}, {1, 6} } -> Center
    },
    ItemSize -> { {Automatic}, {{1.2}} },
    Spacings -> { 1.4, { 1.5, 0.5, -1, { 0.2 }, -1 } },
    Dividers -> { 
      { Thickness[Medium], Thickness[Tiny] , { Thickness[Medium] } },
      { Thickness[Medium], False, Thickness[Medium], { False }, Thickness[Medium] }
    }
  ]
];


OutputQuantityGrid[] := 
Module[
  {
    fEst    = \[CapitalKoppa]fEstimate,
    fMaxUnc = \[CapitalKoppa]fMaximumUncertainty,
    fStdUnc = \[CapitalKoppa]Y$CoverFactor * \[CapitalKoppa]fStandardUncertainty,
    fMin    = \[CapitalKoppa]fMinValue,
    fMax    = \[CapitalKoppa]fMaxValue,
    covFact = \[CapitalKoppa]Y$CoverFactor,
    ucvStd, ucvMax
  },

  ucvStd = RoundOff[ ToUc\[ScriptCapitalV][ fEst \[PlusMinus] fStdUnc ], $UcPrecision ];
  ucvMax = RoundOff[ ToUc\[ScriptCapitalV][ fEst \[PlusMinus] fMaxUnc ], $UcPrecision ];

  Grid[
    Join[
      {
        { "y", NumberBox[ fEst ] // DisplayForm,
          "", ""
        },
        { If[ covFact == 1, "\!\(\*SubscriptBox[\"u\", \"c\"]\)", StringForm[ "``\[InvisibleTimes]\!\(\*SubscriptBox[\"u\", \"c\"]\)", covFact ] ],
          NumberBox[ fStdUnc ] // DisplayForm,
          "=", PercentForm[ fStdUnc, fEst ]
        },
        { If[ covFact == 1, "y\[MediumSpace]\[PlusMinus]\[MediumSpace]\!\(\*SubscriptBox[\"u\", \"c\"]\)", StringForm[ "y\[MediumSpace]\[PlusMinus]\[MediumSpace]``\[InvisibleTimes]\!\(\*SubscriptBox[\"u\", \"c\"]\)", covFact ] ], 
          UcBox[ ucvStd ] // DisplayForm,
          "=", UcBox[ ucvStd, Condensed -> True ] // DisplayForm
        },
        { "\!\(\*SubscriptBox[\"\[CurlyEpsilon]\", \"max\"]\)", NumberBox[ fMaxUnc ] // DisplayForm,
          "=", PercentForm[ fMaxUnc, fEst ]
        },
        { "y\[MediumSpace]\[PlusMinus]\[MediumSpace]\!\(\*SubscriptBox[\"\[CurlyEpsilon]\", \"max\"]\)", UcBox[ ucvMax ] // DisplayForm,
          "=", UcBox[ ucvMax, Condensed -> True ] // DisplayForm
        },
        { "\!\(\*SubscriptBox[\"y\", \"min\"]\)", NumberBox[ fMin[[1]] ] // DisplayForm,
          "=", NumberForm[ fMin[[1]] - fEst, 6, NumberSigns -> { "y\[MediumSpace]-\[MediumSpace]", "y\[MediumSpace]+\[MediumSpace]" } ]
        },
        { "\!\(\*SubscriptBox[\"y\", \"max\"]\)", NumberBox[ fMax[[1]] ] // DisplayForm,
          "=", NumberForm[ fMax[[1]] - fEst, 6, NumberSigns -> { "y\[MediumSpace]-\[MediumSpace]", "y\[MediumSpace]+\[MediumSpace]" } ]
        }
      }
    ],
    Alignment -> { {{Left}}, {{Baseline}} },
    ItemSize -> { {{Automatic}}, {{1.5}} },
    Spacings -> { { 2, {2}, 1, 0.5, 2 }, { 0.5, { 0.5, 0.2 }, 0.5 } },
    Dividers -> { 
      { { Thickness[Medium] }, False, False, Thickness[Medium] },
      { Thickness[Medium], { Thickness[Tiny], False }, Thickness[Medium] }
    }
  ]
];


SetAttributes[ \[CapitalKoppa]UC, Listable ];


\[CapitalKoppa]UC[ expr_, ucPrec_: Null, prec_: Null ] :=
If [ expr === Null, (* Then *) Null, (* Else *)
  DisplayUc\[ScriptCapitalV][ expr,
    If[ ucPrec =!= Null, ucPrec, $UcPrecision ],
    If[ prec =!= Null, prec, $EstPrecision ]
  ]
];


SetAttributes[ \[CapitalKoppa]UCU, { HoldAllComplete, Listable } ];


\[CapitalKoppa]UCU[ expr_, name_: Null, unit_: Null, OptionsPattern[] ] :=
Module[
  {
    ucPrec = If[ OptionValue[ UcPrecision ] =!= Null, OptionValue[ UcPrecision ], $UcPrecision ],
    prec = If[ OptionValue[ Precision ] =!= Null, OptionValue[ Precision ], $EstPrecision ],
    qty, qtyOpts
  },

  If [ expr === Null, Return[] ];

  qtyOpts = Flatten[{
    If[ name === Null, (* Then *) {}, 
    (* Else *)
      { Name -> FormBox[ 
        Style[ HoldForm[ name ], FontFamily -> "Euclid" ], TraditionalForm
      ] }
    ],
    If[ unit === Null, (* Then *) {}, 
    (* Else *)
      { Unit -> If[ False,
        (* Then*) ImportUnits[ Unevaluated[ unit ] ],
        (* False*)StyleBox[ ImportUnits[ Unevaluated[ unit ] ], FontFamily -> "Euclid" ]
      ] }
    ]
  }];

  qty = ToUc\[ScriptCapitalV][ expr, Sequence @@ qtyOpts ];

  DisplayUc\[ScriptCapitalV][ qty, ucPrec, prec ]
];


SetAttributes[ \[CapitalKoppa]UCResult, { HoldAllComplete, Listable } ];


\[CapitalKoppa]UCResult[ name_: Null, unit_: Null, opts: OptionsPattern[] ] :=
Module[
  { qty, oldCoverFactor },

  (* extended uncertainty with cover factor *)
  If[ OptionValue[ CoverFactor ] =!= Null, \[CapitalKoppa]Y$CoverFactor = OptionValue[ CoverFactor ] ];

  (* get \[CapitalKoppa]Y without any name/unit displaying options *)
  \[CapitalKoppa]Y$Options = {};
  qty = \[CapitalKoppa]Y;

  (* update displaying options for \[CapitalKoppa]Y *)
  \[CapitalKoppa]Y$Options = Flatten[{
    If[ name === Null, {}, { Name -> NameAsIs[ name ] } ],
    If[ unit === Null, {}, { Unit -> ImportUnits[ unit ] } ]
  }];

  \[CapitalKoppa]UCU[ qty, name, unit, opts ]
];


\[CapitalKoppa]UCA[ expr_, ucPrec_: Null, prec_: Null ] :=
  \[CapitalKoppa]UC[ expr /. \[CapitalKoppa]AsStandardUncertainty, ucPrec, prec ];


\[CapitalKoppa]UCE[ expr_, ucPrec_: Null, prec_: Null ] := 
  \[CapitalKoppa]UC[ expr /. \[CapitalKoppa]AsMaximumUncertainty, ucPrec, prec ];


ToMetafile[ expr_ ] :=
Module[
  {},
  CellPrint[ ExpressionCell[ expr, "Output" ] ];
  If [ SelectionMove[ FrontEnd`SelectedNotebook[], All, GeneratedCell ] =!= $Failed, 
    FrontEndExecute[{
      FrontEndToken[ FrontEnd`SelectedNotebook[], "SelectionConvert", "Metafile" ]
    }]
  ]
];


SetAttributes[ SetInputQuantities, HoldAll ];


SetInputQuantities::invar = "The right part must be a matrix with at least 3 columns:\n args \[Equal] `1`"


SetInputQuantities[ args_? MatrixQ ] :=
Module[
  { 
    n, Xname, Xvalue, Xunit, Xdist, i
  },
  If[ ! MatrixQ[args] || Dimensions[args][[2]] < 3,
    Message[ SetInputQuantities::invar, args ];
    Abort[]
  ];

  (* get number of input quantities *)
  n = Length[ args ];

  (* column 1 == symbols *)
  Xname = Table[ Hold[ args ][[All,i,1]], {i,n} ] /. Hold[e_] :> NameAsIs[e];

  (* column 2 == values *)
  Xvalue = args[[ All, 2 ]]; 

  (* column 3 == distributions *)
  Xdist = args[[ All, 3 ]];

  (* column 4 (optional) == units *)
  Xunit = If[ Dimensions[args][[2]] >= 4,
  (* Then *)
     Table[ Hold[ args ][[All,i,4]], {i,n} ] 
       /. Hold[e_] :> ImportUnits[ Unevaluated[e] ] 
       /. ex_ :> If[ StringQ[ex] 
                && ( ex == "Null" || ex == "" || StringMatchQ[ ex, Whitespace ] ), 
                  (* Then *) Null,
                  (* Else *) ex
                ],
  (* Else *)
     Table[ Null, {n} ]
  ] ;

  (* update uc values to symbols *)
  Do[ 
    Xvalue[[i]] = ToUc\[ScriptCapitalV][
         Xvalue[[i]], Name -> Xname[[i]],
         Sequence @@ If[ Xunit[[i]] =!= Null, { Unit -> Xunit[[i]] }, {}, {} ], 
         Sequence @@ If[ Xdist[[i]] =!= Null, { Distribution -> Xdist[[i]] }, {}, {} ]
    ],
    { i, n }
  ];

  (* clear current symbol values *)
  Clear /@ Xname;

  (* assign new values to symbols *)
  Do[ 
    ToExpression[ Xname[[i]] <> " = " <> ToString[ Xvalue[[i]], InputForm ] ],
    { i, n }
  ];

  Transpose[{ Xname, Table[ "=", {n} ], ToExpression /@ Xname }] // TableForm
]


SetAttributes[ AddInputQuantities, HoldAll ];


AddInputQuantities[ left_? ListQ , inQty_? MatrixQ ]:=
Module[
  { right, n },

  n = Length[ inQty ];

  right = Table[
    Table[ Hold[ inQty ][[All,i,j]], { j, Length[ inQty[[i]] ] } ],
    { i, n }
  ];

  n= Length[ right ];

  right = Transpose[ right ];
  If[ Length[right] < 3, right = Join[ right, { Table[ Null, {n} ] } ] ];
  If[ Length[right] < 4, right = Join[ right, { Table[ Null, {n} ] } ] ];
  right = right[[;;4]];
  right = Join[ right, { right[[1]] } ];
  right = Transpose[ right ];

  If[ left === Null || left == {} || left == {{}},
    Return[ right ]
  ];

  Join[ Complement[ left, right, SameTest->( #1[[1]] === #2[[1]]&) ], right ]
];


SetAttributes[ ToUc\[ScriptCapitalF], HoldAll ];


ToUc\[ScriptCapitalF][ anonymousInputQuantities_ ]:= Uc\[ScriptCapitalF][];


ToUc\[ScriptCapitalF][ anonymousInputQuantities_? MatrixQ ]:=
Module[
  { ucQuantities, n, i },

  ucQuantities = anonymousInputQuantities;

  n = Length[ ucQuantities ];

  (* clear symbols from input quantities *)
  ucQuantities[[All,1]] /. Hold[e_] :> Quiet[ e =. ];

  (* convert to Uc\[ScriptCapitalV] input quantities *)
  Do[
    Module[ 
      { symbol, value, dist, unit, name },

      symbol = ReleaseHold[ ucQuantities[[i,1]] ];
      value  = ReleaseHold[ ucQuantities[[i,2]] ];
      dist   = ReleaseHold[ ucQuantities[[i,3]] ];
      name   = ucQuantities[[i,1]] /. Hold[e_] :> ToString[ Unevaluated[e], InputForm ];

      unit = ucQuantities[[i,4]] 
        /. Hold[e_] :> ImportUnits[ Unevaluated[e] ] 
        /. ex_ :> If[ StringQ[ex] 
                     && ( ex == "Null" || ex == "" || StringMatchQ[ ex, Whitespace ] ), 
                 (* Then *) Null,
                 (* Else *) ex
                 ];

      value = ToUc\[ScriptCapitalV][
         value, Name -> name,
         Sequence @@ If[ unit =!= Null, { Unit -> unit }, {}, {} ], 
         Sequence @@ If[ dist =!= Null, { Distribution -> dist }, {}, {} ]
      ];

      ucQuantities[[i]] = { symbol, name, value };
    ],
    { i, n }
  ];

  ReplacePart[ ucQuantities, 0 -> Uc\[ScriptCapitalF] ]
];


SetAttributes[ SetupFunctionalRelationship, HoldAll ];


SetupFunctionalRelationship[ ucExpr_, anonymousInputQuantities_: Null ] :=
Module[
  {
    foo, (* functional relationship *)
    n, (* number of dummy symbols *)
    ucQuantities = Uc\[ScriptCapitalF][], (* col 1 = dummy symbol, col 2 = name, col 3 = Uc\[ScriptCapitalV] *)
    dummySymMap = {}, (* col 1 = temp symbol name, col 2 = dummy sym name *)
    ucTempSymN = 0, (* ucTempSym counter *)
    ucQuantitiesFromUc\[ScriptCapitalF], (* from anonymous quantitites *)
    Debug = 0,
    remap, i
  },

  ucQuantitiesFromUc\[ScriptCapitalF] = ToUc\[ScriptCapitalF][ anonymousInputQuantities ];

  If[ Debug >= 1, Print[ 
    "---- PARSING --------------------------------------------\n",
    HoldForm[ ucExpr ]
  ] ];

  (* Note: dummy symbol names are names of the input quantities *)

  foo = ReplaceAll[
    Unevaluated[ ucExpr ],
    expr_? Uc\[ScriptCapitalV]Q :>
      Module[ 
        { symName, ucTempSym, qty, curName, anonymous },

        symName = Quiet[ SymbolName[ Unevaluated[ expr ] ] ];
        (*ucTempSym = Unique[ "\[FivePointedStar]" ];*)
        ucTempSym = Symbol[ "\[LeftGuillemet]" <> ToString[ ++ucTempSymN ] <> "\[RightGuillemet]" ];

        anonymous = Head[symName] === SymbolName;
        If[ anonymous, symName = SymbolName[ ucTempSym ] ];

        curName = Uc\[ScriptCapitalV]$Option[ expr, Name ];
        If [ ! anonymous || ( anonymous && curName === Null ),
          (* Then *) qty = ToUc\[ScriptCapitalV][ expr, Name -> symName ]; curName = symName,
          (* Else *) qty = ToUc\[ScriptCapitalV][ expr ]
        ];

        If[ UCQuantity`Private`NullifyIfEmpty[ curName ] === Null, curName = symName ];

        ucQuantities = Union[ ucQuantities, Uc\[ScriptCapitalF][{ curName, curName, qty }] ];
        dummySymMap = Join[ dummySymMap, {{ ucTempSym, curName }} ];

        If[ Debug >= 1,
          Print[ ucTempSym, " \[RuleDelayed] (", curName, "): ", 
                 Unevaluated[ expr ], " \[Rule] ", expr ]
        ];

        ucTempSym (* returns temporary uc symbol name *)
      ]
  ];

  n = Length[ dummySymMap ];

  If[ Debug >= 2, Print[ 
    "---- RESULT ---------------------------------------------\n", foo, "\n", 
    "Uc quantities:\n", ucQuantities // TableForm, "\n", 
    "Symbol map:\n", dummySymMap // TableForm
  ] ];

  (* Replace named symbols with temp symbols *)
  remap = Table[ dummySymMap[[i,2]] -> dummySymMap[[i,1]], { i, n } ];
  Do[ ucQuantities[[i,1]] = ucQuantities[[i,1]] /. remap, { i, Length[ucQuantities] } ];
  dummySymMap[[All,2]] = dummySymMap[[All,2]] /. remap;

  (* Replace temp symbols with dummy syms in initial expression *)
  foo = foo /. Table[ dummySymMap[[i,1]] -> dummySymMap[[i,2]], { i, n } ];

  ucQuantities = Join[ ucQuantities, ucQuantitiesFromUc\[ScriptCapitalF] ];

  If[ Debug >= 2, Print[ 
    "---- AFTER ----------------------------------------------\n", foo, "\n", 
    "Uc quantities:\n", ucQuantities // TableForm, "\n", 
    "Symbol map:\n", dummySymMap // TableForm
  ] ];

  Join[ Uc\[ScriptCapitalF][ foo ], ucQuantities ]
];


SetupUA::invar = "SetupUA accepts only non-empty Uc\[ScriptCapitalF] objects. Got ucf \[Equal] `1`";
SetupUA::invfr = "First part of the Uc\[ScriptCapitalF] in SetupUA must be an expression. Got ucf \[Equal] `1`";
SetupUA::invar = "Uncercognized argument `1` in SetupUA";
SetupUA::indet = "`1` could not be evaluated as a numeric value (`1` \[Equal] `2`).";


SetupUA[ expr_Uc\[ScriptCapitalF] ] := Module[ {},
  Message[ SetupUA::invar, expr ];
  Abort[]
];


SetupUA[ expr_ ] :=
  SetupUA[ SetupFunctionalRelationship[ expr ] ];


SetupUA[ ucf: Uc\[ScriptCapitalF][ foo___, inputQuantities: {_,_,_}... ] ] :=
Module[
  {
    xSymb = "x", uSymb = "u", \[CurlyEpsilon]Symb = "\[CurlyEpsilon]",
    ucQuantities = List[ inputQuantities ],
    colSymbol = 1, colName = 2, colValue = 3,
    Xsymbol, Xname, X,
    Vector, Domain, NameRules, SubNameRules,
    EstRules, StdUncRules, MaxUncRules, i
  },

  ClearUA[];

  If[ False, Module[
    { ucDump = ucQuantities /. Uc\[ScriptCapitalV] -> ( DisplayForm@ UcBox[ Uc\[ScriptCapitalV][ ## ] ] &) },
    CellPrint[ ExpressionCell[ DisplayForm@ StyleBox[
      RowBox[{
        ToBoxes[ foo ], "   ", "\[RightTeeArrow]", " ",
        ToBoxes[ TableForm[ ucDump ] ]
      }],
      FontWeight -> Bold
    ], "Output" ] ]
  ] ];

  (* Get number of input quantities as n and assert that n >= 0. *)
  n = Length[ ucQuantities ];
  If[ n < 0, 
    Message[ SetupUA::invar, ucf ];
    Abort[]
  ];

  (* assert that functional relationship exists *)
  If[ foo === Null || Length[ {foo} ] != 1,
    Message[ SetupUA::invfr, ucf ];
    Abort[]
  ];

  (* clear anonymous vectors x, u and \[CurlyEpsilon] *)
  Quiet@ ToExpression[ RowBox[{ xSymb, "=." }] ];
  Quiet@ ToExpression[ RowBox[{ uSymb, "=." }] ];
  Quiet@ ToExpression[ RowBox[{ \[CurlyEpsilon]Symb, "=." }] ];
  Quiet@ Do[ 
    ToExpression[ RowBox[{ SubscriptBox[ xSymb, i ], "=." }] ];
    ToExpression[ RowBox[{ SubscriptBox[ uSymb, i ], "=." }] ];
    ToExpression[ RowBox[{ SubscriptBox[ \[CurlyEpsilon]Symb, i ], "=." }] ],
    { i, n }
  ];
  
  (* Functions to access column with symbols and symbol names *)
  Xsymbol[ i_ ] := ucQuantities[[ i, colSymbol ]] /; 1 <= i <= n;
  Xname[ i_ ] := ToExpression[ ucQuantities[[ i, colName ]], StandardForm, HoldForm ] /; 1 <= i <= n;

  (* Function to access column with values *)
  X[ i_ ] := ToUc\[ScriptCapitalV][ ucQuantities[[ i, colValue ]] ] /; 1 <= i <= n;

  (* Distribution of the input quantity *)
  fDist[ i_ ] := Distribution@ X[i] /; 1 <= i <= n;

  f[ x_Symbol ] := foo /. Table[ Xsymbol[i] -> Subscript[x, i], { i, n } ];

  f[ x__ ] := ( foo /. Table[ Xsymbol[i] -> List[x][[i]], { i, n } ] ) 
           /; Length[List[x]] == n;

  Vector[ sym_Symbol ]       := Table[ Subscript[sym, i],            { i, n } ];
  NameRules[ sym_Symbol ]    := Table[ Subscript[sym, i] -> Xname[i], { i, n } ];
  SubNameRules[ sym_Symbol ] := Table[ Subscript[sym, i] -> Subscript[sym, Xname[i]], { i, n } ]; (* sym[Xname[i]] *)

  EstRules[ x_Symbol ]     := Table[ Subscript[x, i] -> Estimate@ X[i],       { i, n } ];
  StdUncRules[ u_Symbol ]  := Table[ Subscript[u, i] -> StdUncertainty@ X[i], { i, n } ];
  MaxUncRules[ \[CurlyEpsilon]_Symbol ]  := Table[ Subscript[\[CurlyEpsilon], i] -> MaxUncertainty@ X[i], { i, n } ];

  Domain[ x_Symbol ] := 
  Table[ 
      Module[ 
        { a = Estimate@ X[i], b = MaxUncertainty@ X[i] },
        If[ ! NumericQ[ a ] || ! NumericQ[ b ],
          (* Then *) False, (* impossible domain *)
          (* Else *) If[ b == 0, 
              (* Then *) Subscript[x, i] == a, 
              (* Else *) a - b <= Subscript[x, i] <= a + b
            ]
        ]
      ],
    { i, n }
  ];

  \[CapitalKoppa]MaxSigFigures := Max[ Table[ 
    If[ UncertainUc\[ScriptCapitalV]Q[ X[i] ], SigFigures[ X[i] ], 0, 0 ],
    { i, n } 
  ] ];

  \[CapitalKoppa]VerboseArgs = Join[
    NameRules[ Symbol[xSymb] ],
    SubNameRules[ Symbol[uSymb] ],
	SubNameRules[ Symbol[\[CurlyEpsilon]Symb] ]
  ];

  SetAttributes[ \[CapitalKoppa]Verbose, HoldAllComplete ];
  \[CapitalKoppa]Verbose[ expr_ ] := HoldForm[ expr ] == ( expr /. \[CapitalKoppa]VerboseArgs );

  \[CapitalKoppa]Vector = Vector[ Symbol[xSymb] ];

  \[CapitalKoppa]AsStandardUncertainty := Riffle[
    EstRules[ Symbol[xSymb] ],
    StdUncRules[ Symbol[uSymb] ]
  ];

  \[CapitalKoppa]AsMaximumUncertainty := Riffle[
    EstRules[ Symbol[xSymb] ],
    MaxUncRules[ Symbol[\[CurlyEpsilon]Symb] ]
  ];
  
  \[CapitalKoppa]fDomain := N@ Domain[ Symbol[xSymb] ];

  \[CapitalKoppa]X[ i_ ] := X[i] /; 1 <= i <= n;

  \[CapitalKoppa]Y$Options = { Name -> StyleBox[ "\[CapitalKoppa]Y", FontColor -> Blue, Bold ] };
  \[CapitalKoppa]Y$CoverFactor = 1;

  \[CapitalKoppa]Y := ToUc\[ScriptCapitalV][
    \[CapitalKoppa]fEstimate \[PlusMinus] ( \[CapitalKoppa]fStandardUncertainty * \[CapitalKoppa]Y$CoverFactor ),
    Distribution -> Normal\[ScriptCapitalD], CoverFactor -> \[CapitalKoppa]Y$CoverFactor,
    Sequence @@ \[CapitalKoppa]Y$Options
  ];

  \[CapitalKoppa]fSensitivityOfX[ i_ ] := 
  Module[
    { x, result },
    result = Abs[ \!\(
\*SubscriptBox[\(\[PartialD]\), 
SubscriptBox[\(x\), \(i\)]]\(f[x]\)\) /. EstRules[ x ] ];
    If [ NumericQ[ result ], result,
      Message[ SetupUA::indet, "\[CapitalKoppa]fSensitivityOfX[" <> ToString[i] <> "]", result ];
      Indeterminate
    ]
  ];

  \[CapitalKoppa]fEstimate :=
  Module[
    { x, result },
    result = f[x] /. EstRules[ x ];
    If [ NumericQ[ result ], result,
      Message[ SetupUA::indet, "\[CapitalKoppa]fEstimate", result ];
      Indeterminate
    ]
  ];

  \[CapitalKoppa]fStandardUncertainty := 
  Module[
    { x, u, result },
    result = (\!\(
\*UnderoverscriptBox[\(\[Sum]\), \(i = 1\), \(n\)]
\*SuperscriptBox[\((\((
\*SubscriptBox[\(\[PartialD]\), 
SubscriptBox[\(x\), \(i\)]]f[x])\) 
\*SubscriptBox[\(u\), \(i\)])\), \(2\)]\))^(1/2) /. Join[ EstRules[ x ], StdUncRules[ u ] ];
    If [ NumericQ[ result ], result,
      Message[ SetupUA::indet, "\[CapitalKoppa]fStandardUncertainty", result ];
      Infinity
    ]
  ];

  \[CapitalKoppa]fMaximumUncertainty :=
  Module[
    { x, \[CurlyEpsilon], result },
    result = \!\(
\*UnderoverscriptBox[\(\[Sum]\), \(i = 1\), \(n\)]\((\[LeftBracketingBar]
\*SubscriptBox[\(\[PartialD]\), 
SubscriptBox[\(x\), \(i\)]]f[x]\[RightBracketingBar]\ 
\*SubscriptBox[\(\[CurlyEpsilon]\), \(i\)])\)\) /. Join[ EstRules[ x ], MaxUncRules[ \[CurlyEpsilon] ] ];
    If [ NumericQ[ result ], result,
      Message[ SetupUA::indet, "\[CapitalKoppa]fMaximumUncertainty", result ];
      Infinity
    ]
  ];

  \[CapitalKoppa]fMinValue :=
  Module[
    { x = Symbol[xSymb], domain, result },

    PrintTemporary[ Style[ "Finding minimum of f[x]...", FontColor -> Red ] ];

    domain = And @@ Domain[ x ];

    result = If[ n == 0 || domain === False,
    (* Then *)
      { \[CapitalKoppa]fEstimate, {} }, 
    (* Else *)
      NMinimize[
        { f[ x ], domain }, Vector[ x ],
        WorkingPrecision -> \[CapitalKoppa]MaxSigFigures + 6,
        MaxIterations -> 200
      ]
    ];

    If [ ListQ[ result ] && NumericQ[ result[[1]] ], result,
      Message[ SetupUA::indet, "\[CapitalKoppa]fMinValue", result ];
      { Indeterminate, {} }
    ]
  ];
  
  \[CapitalKoppa]fMaxValue :=
  Module[
    { x = Symbol[xSymb], domain, result },

    PrintTemporary[ Style[ "Finding maximum of f[x]...", FontColor -> Red ] ];

    domain = And @@ Domain[ x ];

    result = If[ n == 0 || domain === False,
    (* Then *)
      { \[CapitalKoppa]fEstimate, {} }, 
    (* Else *)
      NMaximize[
        { f[ x ], And @@ Domain[ x ] }, Vector[ x ],
        WorkingPrecision -> \[CapitalKoppa]MaxSigFigures + 6,
        MaxIterations -> 200
      ]
    ];

    If [ ListQ[ result ] && NumericQ[ result[[1]] ], result,
      Message[ SetupUA::indet, "\[CapitalKoppa]fMaxValue", result ];
      { Indeterminate, {} }
    ]
  ];

  \[CapitalKoppa]FunctionalRelationship :=
  Module[
    { x = Symbol[xSymb] },
    StyleBox[
      RowBox[{ "y", "=", ToBoxes[ f[x] ] }],
      FontWeight -> Bold, FontSize -> Larger, FontColor -> Darker[Blue]
    ] // DisplayForm
  ];

  \[CapitalKoppa]InputQuantities := If[ n != 0, Style[
    InputQuantitiesGrid[ xSymb, X, n ],
    FontSize -> Inherited, FontWeight -> Bold
  ]] ;

  \[CapitalKoppa]AnalysisResult := Style[
    OutputQuantityGrid[],
    FontSize -> Inherited, FontWeight -> Bold
  ];

  \[CapitalKoppa]AnalysisEnvironment := Module[ {},
    CellPrint[ ExpressionCell[ \[CapitalKoppa]FunctionalRelationship, "Output" ] ];
    If[ n != 0, CellPrint[ ExpressionCell[ \[CapitalKoppa]InputQuantities, "Output" ] ] ];
    CellPrint[ ExpressionCell[ \[CapitalKoppa]AnalysisResult, "Output" ] ]
  ];

  \[CapitalKoppa]DumpRelationship :=
  Module[
    { x = Symbol[xSymb], nameBox = Uc\[ScriptCapitalV]$NameBox[ \[CapitalKoppa]Y ] },
    If[ nameBox =!= Null,
    (* Then *)
       DisplayForm@ RowBox[{
         Uc\[ScriptCapitalV]$NameBox[ \[CapitalKoppa]Y ], "=", 
         RowBox[{ f[x] /. \[CapitalKoppa]VerboseArgs }]
       }],
    (* Else *)
       f[x] /. \[CapitalKoppa]VerboseArgs
    ]
  ];

  \[CapitalKoppa]DumpQuantities :=
  Module[ {},
    Function[ e, ExpressionCell[ e, "Output" ] ]
    /@ Join[ 
      { \[CapitalKoppa]UC[ \[CapitalKoppa]Y, $UcPrecision ] },
      Table[ \[CapitalKoppa]UC@ \[CapitalKoppa]X[i], { i, n } ]
    ] // CellPrint;
  ];
];


ClearUA[] :=
Clear[ n, fDist, f, 
  \[CapitalKoppa]VerboseArgs, \[CapitalKoppa]Verbose, \[CapitalKoppa]Vector, \[CapitalKoppa]AsStandardUncertainty, \[CapitalKoppa]AsMaximumUncertainty,
  \[CapitalKoppa]fDomain, \[CapitalKoppa]X, \[CapitalKoppa]Y$Options, \[CapitalKoppa]Y, \[CapitalKoppa]fSensitivityOfX,
  \[CapitalKoppa]fEstimate, \[CapitalKoppa]fStandardUncertainty, \[CapitalKoppa]fMaximumUncertainty, \[CapitalKoppa]fMinValue, \[CapitalKoppa]fMaxValue,
  \[CapitalKoppa]FunctionalRelationship, \[CapitalKoppa]InputQuantities,
  \[CapitalKoppa]AnalysisResult, \[CapitalKoppa]AnalysisEnvironment, \[CapitalKoppa]DumpQuantities
];


SetAttributes[ RightTeeArrow, HoldAllComplete ];


RightTeeArrow[ expr_, args_ ] := Module[ 
  { foo, ucvs },
  ucvs = AddInputQuantities[ {}, Unevaluated[ args ] ];
  foo = SetupFunctionalRelationship[ Unevaluated[ expr ], ucvs  ];
  SetupUA[ foo ]
];


$Pre = TimeIt;


End[];


EndPackage[];
